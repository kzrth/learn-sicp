# 1.1.5. Подстановочная модель применения процедуры

## Аппликативный и нормальный порядки вычисления

Процесс составных процедур - чтобы применить составную процедуру к аргументам, нужно вычислить тело процедуры, заменив каждый формальный параметр соответствующим аргументом.

```scheme
(define (square x) (* x x))

(define (sum-of-squares x y) (+ (square x) (square y)))

(define
	(f a)
	(sum-of-squares (+ a 1) (* a 2)))

(f 5) ;136
```

## Аппликативный порядок вычисления

Чтобы применить составную процедуру к аргументам, нужно вычислить тело процедуры, заменив каждый формальный параметр соответствующим аргументом.

```scheme
(f 5)
```

### 1. Восстанавливаем тело `f`

```scheme
(sum-of-squares (+ a 1) (* a 2))
```

### 2. Заменяем формальный параметр на аргумент

```scheme
(sum-of-squares (+ 5 1) (* 5 2))
```

### 3. Вычисляем операнды, чтобы заменить формальные параметры на аргументы

Задача сводится к вычислению комбинации с двумя операндами и оператором `sum-of-squares`

- оператор - `sum-of-squares`
- операнд - `(+ 5 1)` (комбинация с двумя операндами (`5` и `1`) и оператором `+`
- операнд - `(* 5 2)` (комбинация с двумя операндами (`5` и `1`) и оператором `*`

Вычисление этой комбинации включает три подзадачи.

Нужно вычислить оператор, чтобы получить процедуру. Другими словами восстановить тело процедуры `sum-of-squares`, как мы до этого сделали с процедурой `f`, а так же вычислить операнды, чтобы получить аргументы. 

Формальный параметр `x` является комбинацией `(+ 5 1)`. Чтобы заменить формальный параметр на аргумент, нужно вычислить комбинацию. 

Формальный параметр `y` является комбинацией `(* 5 1)`. Чтобы заменить формальный параметр на аргумент, нужно вычислить комбинацию. 

Комбинация `(+ 5 1)` даёт `6`, а комбинация `(* 5 2)` даёт `10`. 

### 4. Заменяем формальные параметры на аргументы

Таким образом на нужно применить процедуру `sum-of-squares` к аргументам `6` и `10`.

```scheme
(sum-of-squares 6 10)
```

### 5. Восстанавливаем тело процедуры `sum-of-squares`

```scheme
(+ (square 6) (square 10))
```

### 6. Восстанавливаем тело процедуры `square`

```scheme
(+ (* 6 6) (* 10 10))
```

### 7. Вычисляем вложенные комбинации

```scheme
(+ 36 100)
```

### 8. Вычисляем последнюю комбинацию и получаем результат

```scheme
136
```

В аппликативном порядке вычисление интерпретатор сначала вычисляет оператор и операнды, а затем применяет получившуюся процедуру к получившимся аргументам.

## Нормальный порядок вычислений

В нормальном порядке вычисление интерпретатор не вычисляет аргументы, пока не понадобятся их значение. Эта модель подставляет на место параметров выражения-операнды, пока не получит выражение, в котором присутствуют только элементарные операторы, и лишь затем вычисляет его. Рассмотрим тот же пример:

```scheme
(f 5)

; последовательность подстановок

(sum-of-squares (+ 5 1) (* 5 2))

(+ (square (+ 5 1)) (square (* 5 2)))

(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))

; затем редукции

(+ (* 6 6) (* 10 10))

(+ 36 100)

136
```

В lisp используется аппликативный порядок вычислений (**applicative-order evaluation**)
