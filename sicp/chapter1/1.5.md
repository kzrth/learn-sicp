# Упражнение 1.5

Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком вычислений он работает, аппликативным или нормальным. Бен определяет такие две процедуры:

```scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
		0 
		y))
```

Затем он вычисляет выражение

```scheme
(test 0 (p))
```

Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок вычислений? Какое поведение он увидит, если интерпретатор использует нормальный порядок? Объясните Ваш ответ. (Предполагается, что правило вычисления особой формы if одинаково независимо от того, какой порядок вычислений используется. Сначала вычисляется выражение-предикат, и результат определяет, нужно ли вычислять выражение-следствие или альтернативу.)

## Решение

### Аппликативный порядок

Перед тем как восстановить тепло процедуры `test` нужно вычислисть операнды

Оператор - `test`

Операнд - `0`

Операнд - `(p)`

```scheme
(test x y)
```

#### Вычисляем операнды

Формальный параметр `x` является числом `0`. Тут не надо ничего вычислять, просто заменяем `x` на `0`

Формальный параметр `y` является процедурой `(p)`. Вычисляем процедуру `(p)` и попадаем в бесконечную рекурсию

```scheme
(p) => (p) => (p) => (p) ...
```

### Нормальный порядок

интерпретатор не вычисляет аргументы, пока не понадобятся их значение

```scheme
(if (= x 0) 0 y)

(if (= 0 0) 0 y)

(if #t 0 y)

0
```
